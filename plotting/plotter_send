#!/usr/bin/env python3

import serial, argparse, sys, subprocess
from itertools import chain
from functools import reduce
from PIL import Image
import curtsies
import hpgl

def prompt_input():
    with curtsies.Input() as input:
        for kp in input:
            if kp in ('y', 'n'):
                return kp
            else:
                print("What?")

def max_image_size(images):
    maxX = 0
    maxY = 0
    for i in images:
        maxX = max(maxX, i.size[0])
        maxY = max(maxY, i.size[1])
    return (maxX, maxY)

def paste_up(img, newsize):
    retval = Image.new('RGBA', newsize)
    w, h = newsize
    ow, oh = img.size
    x = w - ow
    y = h - oh
    retval.paste(img, (0, y))
    return retval

def composite_all(images):
    maxsize = max_image_size(images)
    composited = reduce(Image.alpha_composite, map(lambda i: paste_up(i, maxsize), images))
    retval = Image.new('RGB', maxsize, color=(255, 255, 255))
    retval.paste(composited, (0, 0, *maxsize))
    return retval

plotter_settings = {
    "titan3" : {
        "baudrate": 38400,
        "bytesize": serial.EIGHTBITS,
        "xonxoff": True,
        "stopbits":serial.STOPBITS_ONE
    },
    'direct' : {}
}

arg_parser = argparse.ArgumentParser(description="Send an HPGL file to a plotter.")
arg_parser.add_argument('--plotter', default='direct', choices=sorted(plotter_settings.keys()), type=str, help="choose plotter settings.")
arg_parser.add_argument('--dry-run', default=False, const=True, action='store_const', help="Print output to stdout instead of a serial port.")
arg_parser.add_argument('--preview', default=False, const=True, action='store_const', help="Render preview(s) of the plot.")
arg_parser.add_argument('--mirror', default=False, const=True, action='store_const', help="Mirror the plot by flipping on the Y axis.")
arg_parser.add_argument('--draw', default=False, const=True, action='store_const', help="Send the pen pass.")
arg_parser.add_argument('--cut', default=False, const=True, action='store_const', help="Send the cutting pass.")
arg_parser.add_argument('--repeat', type=int, help="Repeat the pattern REPEAT times.")
arg_parser.add_argument('port', type=str, help="The serial port the plotter is connected to.")
arg_parser.add_argument('file', type=str, help="The file of HPGL commands to send.")
args = arg_parser.parse_args()

chosen_plotter_settings = plotter_settings[args.plotter]

# Load and transform plot
plot = hpgl.parse_file(args.file)

if args.mirror:
    plot.mirror()

# Render passes
passes = plot.find_passes()

if args.preview:
    images = []

    images.append(hpgl.image_preview(passes['init'] + passes['knife']))
    images.append(hpgl.image_preview(passes['init'] + passes['pen']))

    composited = composite_all(images)
    composited.show()

    print("Do those look good? (y/n)")
    if prompt_input() == 'n':
        exit(0)

if args.repeat:
    repeated = []
    for b in passes['knife']:
        for i in range(args.repeat):
            repeated.append(b)
    passes['knife'] = repeated

if not (args.draw or args.cut):
    print("Neither --cut nor --draw specified. Exiting.")
    exit(0)

# Open output
out_port = None

if args.dry_run:
    out_port = sys.stdout

if args.plotter == 'direct':
    out_port = open(args.port, 'wb')
else:
    out_port = serial.Serial(port=args.port, **chosen_plotter_settings)

# Plot passes
def write_pass(p):
    out_port.write("".join([str(b) for b in p]).encode('ASCII'))
    out_port.flush()

write_pass(passes['init'])

if args.draw:
    write_pass(passes['pen'])

if args.draw and args.cut:
    while True:
        response = input("Have you inserted the knife? (type 'yes' and hit ENTER) ")
        if response == 'yes':
            break

if args.cut:
    write_pass(passes['knife'])